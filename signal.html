<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Model Display & Pose Animation</title>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #222;
    }
    #renderer-container {
      width: 640px;
      height: 480px;
      border: 1px solid #ccc;
      background-color: #000;
    }
  </style>
</head>
<body>
  <h1>PoseNet & 3D Character Animation</h1>

  <!-- Поле для ввода IP-адреса сервера -->
  <label for="serverIp">Enter Server IP:</label>
  <input type="text" id="serverIp" placeholder="Enter server IP (e.g., 192.168.1.5)" />
  <button id="connectButton">Connect to WebSocket</button>
  <span id="connectionStatus">Not connected</span>

  <!-- Контейнер для рендерера Three.js -->
  <div id="renderer-container"></div>

  <!-- Подключаем Three.js и FBXLoader -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/FBXLoader.js"></script>

  <script>
    let socket;
    let isConnected = false;
    let scene, camera, renderer, model;

    // Инициализация Three.js и отображение модели
    function initThreeJS() {
      // Создаем сцену
      scene = new THREE.Scene();

      // Настраиваем камеру для окна 640x480
      camera = new THREE.PerspectiveCamera(75, 640 / 480, 0.1, 1000);
      camera.position.set(0, 1, 5);

      // Создаем рендерер с фиксированными размерами
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(640, 480);
      document.getElementById('renderer-container').appendChild(renderer.domElement);

      // Добавляем освещение
      const ambientLight = new THREE.AmbientLight(0x404040, 5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(10, 10, 10);
      scene.add(pointLight);

      // Загрузка модели FBX и отображение
      const loader = new THREE.FBXLoader();
      loader.load(
        'character.fbx', // Убедитесь, что файл character.fbx находится рядом с HTML файлом
        function(fbx) {
          model = fbx;
          model.scale.set(0.2, 0.2, 0.2); // Установите нужный масштаб
          scene.add(model);
          
          // Вывод всех объектов и костей модели в консоль после загрузки
          model.traverse(function (child) {
            if (child.isBone) {
              console.log("Bone name:", child.name); // Выводит имена всех костей
            } else {
              console.log("Object name:", child.name); // Выводит имена всех объектов
            }
          });

          animate(); // Начинаем анимацию вращения
        },
        undefined,
        function(error) {
          console.error("Error loading model:", error); // Лог ошибок, если модель не загружается
        }
      );
    }

    // Анимация модели без подключения к серверу
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // Подключение к серверу WebSocket и получение координат
    function connectToServer() {
      const serverIp = document.getElementById('serverIp').value.trim() || 'localhost';
      socket = new WebSocket(`ws://${serverIp}:8080`);
      socket.onopen = () => {
        console.log('WebSocket connection established');
        document.getElementById('connectionStatus').textContent = 'Connected';
        isConnected = true;
      };

      socket.onclose = () => {
        console.log('WebSocket connection closed');
        document.getElementById('connectionStatus').textContent = 'Disconnected';
        isConnected = false;
      };

      socket.onerror = (error) => {
        console.error('WebSocket error:', error);
        alert('Failed to connect to the server. Please check the IP address and try again.');
      };

      socket.onmessage = (event) => {
        const keypointsData = JSON.parse(event.data);
        console.log("Received keypoints data:", keypointsData); // Лог данных для отладки
        updateModelPose(keypointsData); // Обновление позы на основе полученных данных
      };
    }

    // Функция для обновления позы модели на основе данных WebSocket
    function updateModelPose(keypointsData) {
      if (!model) return;

      const keypointsMap = {};
      keypointsData.forEach(kp => {
        keypointsMap[kp.part] = kp;
      });

      function applyPoseToBone(bone, startPoint, endPoint) {
        if (!bone || !startPoint || !endPoint) {
          console.log(`Bone ${bone} or points missing`); // Логирование отсутствующих элементов
          return;
        }

        const startVector = new THREE.Vector3(startPoint.x * 0.01, -startPoint.y * 0.01, 0);
        const endVector = new THREE.Vector3(endPoint.x * 0.01, -endPoint.y * 0.01, 0);
        
        const direction = new THREE.Vector3().subVectors(endVector, startVector).normalize();
        bone.lookAt(direction);
        console.log(`Updated bone ${bone.name} with direction`, direction); // Логирование для отладки
      }

      // Пример привязки костей к ключевым точкам
      applyPoseToBone(model.getObjectByName('LeftShoulder'), keypointsMap['leftShoulder'], keypointsMap['leftElbow']);
      applyPoseToBone(model.getObjectByName('LeftElbow'), keypointsMap['leftElbow'], keypointsMap['leftWrist']);
      applyPoseToBone(model.getObjectByName('RightShoulder'), keypointsMap['rightShoulder'], keypointsMap['rightElbow']);
      applyPoseToBone(model.getObjectByName('RightElbow'), keypointsMap['rightElbow'], keypointsMap['rightWrist']);
    }

    // Запускаем Three.js без подключения к серверу
    initThreeJS();

    // Кнопка для подключения к серверу и начала анимации позы
    document.getElementById('connectButton').onclick = () => {
      if (!isConnected) {
        connectToServer();
      }
    };

    // Фиксируем размер окна на 640x480 и отключаем обновление при изменении размера
    window.addEventListener('resize', () => {
      renderer.setSize(640, 480);
      camera.aspect = 640 / 480;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
